- Python variable do not have pre-defined type
  Any type value can be assigned to the variable

- Python Operators:
Not available in python:
- pointers
- ternary operator(conditional)
- ++ --
available operators
+
-
*
** => power of
:  => slicing
Changed operators
Logical operators => ||  &&  !
    		     or and not

variable on the left gets the actual value of the variable on the right, instead of the boolean value.

0 means failure
non zero(+ve or -ve) means success 
-------------------------


for loop:
- applicable only for containers(list, tuple, dictionary)

eg:
for i in lst1:
  print lst1



Program control flow constructs:
------------------------------
all constructs should end with colon(:)
only way to create a code block in python is by using indentation. No specific rules on number of indentation spaces to be used.


Object:
======
Everything in Python is an object.

- An object has attributes and methods.
- To print the content of an object dir(object_name)
- To check if an item of an object is an attribute or method, type(object.item)
- To display the usage details of a method of an object, help(object.method)

- A method is a function which is bound to an object
- A function is something not bound to any object. Freely available without any object reference.

keyword - Most common and frequently used[usage: keyword <something>]
inbuilt function - most common and les frequently used [usage: function(<something>)]
method - specifically used[usage: object.<methodname>]


Containers:
===========
1. list(Mutable) => uses [] 
2. tuple(Immutable: elements of a tuple are not modifiable whereas tuple can be modified) => uses ()
3. dictionary(key/value pair) => uses {}.
   keys should be unique & immutable
Note: Individual items of all the container can be accessed only with []
      List and tuple's individual items are accessed with index value whereas dictionary's individual elements are accessed using key.
      Any datatype can be set as key. But it is not a good practice to assign mutable types(such as list, dictionary) as key.
      Any container can have any other container as part of its element. And while thinking of the behaviour of the container available within another, always consider the type of innermost container.

To know about the python components:
dict()
 - To get the list of builtins, type dict(__builtin__) 
help(), then type the component you need to check about
 - To get the list of keywords, help("keywords")
 - modules, help("modules")
 - To get details of builtin function, object.method, module.function,module double quote is not required.



Negative Index:
-------------
lst=[10,20,30]
lst[-1] => prints 30
lst[-2] => prints 20


slicing: To slice a part of the value
--------
lst1=[10,20,30,40,50]
print lst1[1:4] => 20,30,40 (prints from index 1 to n-1, ie 4-1=3)
print lst1[:3]  => 10,20,30
print lst1[1:]  => 10,20,30,40,50 (prints from index 1 to n)
print lst1[:] => prints full list

	Generic form
		lst1[      :     :     ]
                      start  end   step

print lst1[: :2] => 10,30
print lst1[1::2] => 20,40


Sequences: Collection of containers excluding dictionaries. Used mostly with indexing and slicing.
----------
lst1=[10,20,(30,40)]
print lst1;
print lst1[0]
print lst1[1]
print lst1[2]
Note: In the above sequence, 10 & 20 are modifiable as they are part of a list. 30 or 40 as an individual element are not modifiable
      as they are part of a tuple. But 30 & 40 together is modifiable as they are part of the outer list.

tup1=(50,60,[70,80])
tup1[2].inseert(1,90)
print tup1
Note: In the above sequence tup1, 50 or 60 as a individual element is not modifiable. 70 or 80 as individual is modifiable. But 70 & 80 together not modifiable.


Function:
---------
def test1():
  <code here>

calling a function,
test1()


- parameter is passed as object in python functions
- mutable objects passed will hold the values updated in the clled function
- immutable objects passed will hold its own value, not the one updated in the called function.

mutable objects:
list, dictionary
immutable objects:
all. Eg: int, string, float, tuple etc


Function overloading is not required in python because of the existence of features called dynamic-typing & positional-arguments/keywords feature.
Constructor overloading is not available in python
operator overloading is available in pytohon.



Class:
===========================
- For class syntax, check the program, classtest.py
- constructor in class is available as __init__(self)
- destructor => __del__()
- In Python methods with starting & ending double underscore has some standard functionality. Eg: __init__(self)
- Every method of a python class should have atleast one parameter. And that parameter holds the object(of that class).
  This parameter is not counted as user given parameter.And it is not required that this parameter should be names as 'self'

access specifiers:
public (no underscore)
semi private (starting with one underscore. same as protected in java. this is not implemented in python exactly. so more or less its same as public)
fully private (starting with two underscore)

dir(__builtins__) contains standard functions and classes. To identify if a specific item is a funtion or class do help(<item>)
- type(input)
  o/p => <type 'builtin_function_or_method'>
  its a function
- type(str)
  o/p => <type 'type'>
  its a class

Inheritance:
class child(parent):
  <code here>

- Multi-level inheritance possible in python.(ie, A inherits B, C inherits A)


the class 'child' is inheriting a class name 'parent'.
- when creating an object of the derived/child class, only derived class's constructor is called. To call parent class constructer also, call the parent class constructor explicly
  within the derived class constructor.

Types of importing:
==================
import math ##the items under math needs to be access as math.<item>
from math import pi ## here pi can be directly used without math.
from math import pi,sin
from math import *
from math import pi as pi_1 
 or 
 from math import pi
 pi_1=pi


module Vs Package:
------------------
- Module appears as a file
- Package appears as a folder/directory with collection of .py files and a mandatory __init__.py
Both module and package work the same way


Regular Expression: Its used for pattern matching.
===================
pattern matching stypes:
1. glob/wild card/meta char
   Used for file/folder names
2. regular expr
   Used for content of files

'grep' uses both glob and reg-exp usage,
grep "^hill" * (or) grep <reg-ex> <globe>


===================

Information:
To made your code non-readable, make it as a .pyc file
- to create a .pyc file, just do import <sample.py> on the terminal, a sample.pyc file is created. It can be used the same way a sample.py file















