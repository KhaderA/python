==> Python variable do not have pre-defined type
  Any type value can be assigned to the variable
  
  Everything in python is an object
  For Instance, a=10
    Here a is a variable of type int. Actually a is an object of type int.
    To check the details of the int object, do dir(int)


Program => code + data
data => variables + constants
code => function bodies


==> Variables:
integer i1=10
long l1=123456L
float f1=12.34
string str1='abc' or "abc" or '''abc''' or """abc"""
            It is recommended to use one single/double quote for string.Triple single/double quote is generally used for documentation.


==> Python Operators:
Not available in python:
- pointers
- ternary operator(conditional)
- ++ --
available operators
+
-
*
** => power of
:  => slicing
Changed operators
Logical operators => ||  &&  !
    		     or and not(in python)

- variable on the left gets the actual value of the variable on the right, instead of the boolean value.

some examples:
2+3          =>    5
'2'+'3'      =>    '23'
'2'+3        =>    Not possible
2*3          =>    6
'2'*3        =>    '222'(Multiplication with an integer works on string in python)
'2'*'3'      =>    Not Possible
2**3         =>    8
:            =>   slicing



==> Failure state in Python
0 means failure
non zero(+ve or -ve) means success 

what else means failure(false value) in python,
"",'',0,0.0,0j,[],(),{},False,None


==> Program control flow constructs:
All constructs should end with colon(:)
Every line falling within the construct should be indented.
only way to create a code block in python is by using indentation. No specific rules on number of indentation spaces to be used.But same spacing for all the statements within a block is mandatory.

if(expr1):
  statement1
elif(expr2):
  st2
else:
  st3
  
while(expr):
  st1
  st2

break
continue

for loop:
- applicable only for containers(list, tuple, dictionary)

eg:
for i in lst1:
  print lst1
  
Not Available in python:
switch,case,do while, goto


Object:
======
Everything in Python is an object.

- An object has attributes and methods.
- To print the content of an object dir(object_name)
- To check if an item of an object is an attribute or method, type(object.item)
- To display the usage details of a method of an object, help(object.method)

==> help with python keywords,modules or any topics:
type help(), it will take you within help interface. type the word for which you need help.

To search for modules related to some action, for instance to search modules related to file,
type "modules files" in help interface.

without entering help interface,
help("keywords") => lists all the python keywords
help("modules") =


- A method is a function which is bound to an object
- A function is something not bound to any object. Freely available without any object reference.

- Attribute is a variable bound to an object.

-----------------------------------------------------------------------------------
keyword - Most common and frequently used[usage: keyword <something>;Eg, print "something"]
inbuilt function - most common and less frequently used [usage: function(<something>);Eg, open("file.txt")]
method - specifically used[usage: object.<methodname>]
attribute - object.attribute

builtin function and class are used in the same manner in python,
function(parameter)
class(parameter)
-----------------------------------------------------------------------------------


Containers:
===========
1. list(Mutable) => uses [] 
2. tuple(Immutable: elements of a tuple are not modifiable whereas tuple can be modified) => uses ()
3. dictionary(key/value pair) => uses {}.
   keys should be unique & immutable
Note: Individual items of all type of containers can be accessed only with []
      List and tuple's individual items are accessed with index value whereas dictionary's individual elements are accessed using key.
      Any datatype can be set as key. But it is not a good practice to assign mutable types(such as list, dictionary) as key.
      Any container can have any other container as part of its element. And while thinking of the behaviour of the container available within another, always consider the type of innermost container.

To know about the python components:
dict()
 - To get the list of builtins, type dict(__builtin__) 
help(), then type the component you need to check about
 - To get the list of keywords, help("keywords")
 - modules, help("modules")
 - To get details of builtin function, object.method, module.function,module double quote is not required.

List(with square bracket): Mutable
==========================
- can hold any type of data
my_list=[10,"abc",10.20]

- can hold list within another list. Even tuples and dictionaries
my_list=["mouse",[8,4,6],['a'],(10,20,30)]

Negative Index:
lst=[10,20,30]
lst[-1] => prints 30
lst[-2] => prints 20

Accessing list elements,
- with index value,
  print my_list[0]  => mouse
  print my_list[1][0] => 8
- with negative indexing,
  print my_list[-1] ==> (10,20,30) ==> prints from right-end-side of list. Here list's last elemnt is a tuple. Hence full tuple will be printed.
  
Slicing list,
my_list=['p','r','o','g',['r','a','m','i','z'] => starts from index value 4 and prints till end.
print my_list[2:5] => ['o', 'g', 'r'] => starts from index 2 and prints till index 5-1  elements. 
print my_list[0:3] => ['p','r','o']
print my_list[:3] => ['p','r','o'] => by default starts from index 0
print my_list[:] => prints complete list
print my_list[4:] => ['r','a','m','i','z'] => starts from index value 4 and prints till end.
print my_list[:-2] => ['p', 'r', 'o', 'g', 'r', 'a', 'm']

slicing: To slice a part of the value
--------
lst1=[10,20,30,40,50]
print lst1[1:4] => 20,30,40 (prints from index 1 to n-1, ie 4-1=3)
print lst1[:3]  => 10,20,30
print lst1[1:]  => 10,20,30,40,50 (prints from index 1 to n)
print lst1[:] => prints full list

	Generic form
		lst1[      :     :     ]
                      start  end   step

print lst1[: :2] => 10,30
print lst1[1::2] => 20,40

Changing/adding elements to a list,
- Using assignment operator,
odd = [2, 4, 6, 8]
odd[0] = 1  => [1,4,6,8]
odd[1:4]=[3,5,7] => [1,3,5,7]

- Add an element to list using append() method,
odd=[1,3,5]
odd.append(7) => [1,3,5,7]
- Add several elements using extend() method,
odd.extend([9,11,13]) => [1,3,5,7,9,11,13]
- Insert item in a desired location using insert(),
odd=[1,9]
odd.insert(1,3) => [1,3,9] => inserts value 3 at index position 1.
odd[2:2]=[5,7] => [1,3,5,7,9] => inserts/replaces new with new values from index position 2 to index position 2.
odd[1:4]=[100,200,300] => [1,100,200,300,9] => replaces the values in position from 1 to 3.

- Deleting follows the same rules as addition.
used 'del' keyword
del odd => deletes entire list
del odd[0]
remove() method can be used to remove the given item.
pop() method can be used to remove an item at the given index. In addition, pop() displays the removed item.


Sequences: Collection of containers excluding dictionaries. Used mostly with indexing and slicing.
----------
lst1=[10,20,(30,40)]
print lst1;
print lst1[0]
print lst1[1]
print lst1[2]
Note: In the above sequence, 10 & 20 are modifiable as they are part of a list. 30 or 40 as an individual element are not modifiable
      as they are part of a tuple. But 30 & 40 together is modifiable as they are part of the outer list.

tup1=(50,60,[70,80])
tup1[2].inseert(1,90)
print tup1
Note: In the above sequence tup1, 50 or 60 as a individual element is not modifiable. 70 or 80 as individual is modifiable. But 70 & 80 together not modifiable.


Function:
---------
def test1():
  <code here>

calling a function,
test1()


- parameter is passed as object in python functions
- mutable objects passed will hold the values updated in the clled function
- immutable objects passed will hold its own value, not the one updated in the called function.

mutable objects:
list, dictionary
immutable objects:
all. Eg: int, string, float, tuple etc


Function overloading is not required in python because of the existence of features called dynamic-typing & positional-arguments/keywords feature.
Constructor overloading is not available in python
operator overloading is available in pytohon.



Class:
===========================
- For class syntax, check the program, classtest.py
- constructor in class is available as __init__(self)
- destructor => __del__()
- In Python methods with starting & ending double underscore has some standard functionality. Eg: __init__(self)
- Every method of a python class should have atleast one parameter. And that parameter holds the object(of that class).
  This parameter is not counted as user given parameter.And it is not required that this parameter should be names as 'self'

access specifiers:
public (no underscore)
semi private (starting with one underscore. same as protected in java. this is not implemented in python exactly. so more or less its same as public)
fully private (starting with two underscore)

dir(__builtins__) contains standard functions and classes. To identify if a specific item is a funtion or class do help(<item>)
- type(input)
  o/p => <type 'builtin_function_or_method'>
  its a function
- type(str)
  o/p => <type 'type'>
  its a class

Inheritance:
class child(parent):
  <code here>

- Multi-level inheritance possible in python.(ie, A inherits B, C inherits A)


the class 'child' is inheriting a class name 'parent'.
- when creating an object of the derived/child class, only derived class's constructor is called. To call parent class constructer also, call the parent class constructor explicly
  within the derived class constructor.

Types of importing:
==================
import math ##the items under math needs to be access as math.<item>
from math import pi ## here pi can be directly used without math.
from math import pi,sin
from math import *
from math import pi as pi_1 
 or 
 from math import pi
 pi_1=pi


module Vs Package:
------------------
- Module appears as a file
- Package appears as a folder/directory with collection of .py files and a mandatory __init__.py
Both module and package work the same way


Regular Expression: Its used for pattern matching.
===================
pattern matching stypes:
1. glob/wild card/meta char
   Used for file/folder names
2. regular expr
   Used for content of files

'grep' uses both glob and reg-exp usage,
grep "^hill" * (or) grep <reg-ex> <globe>


===================

Information:
To made your code non-readable, make it as a .pyc file
- to create a .pyc file, just do import <sample.py> on the terminal, a sample.pyc file is created. It can be used the same way a sample.py file

















